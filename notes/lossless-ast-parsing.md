# Notes on a full fidelity parser
Nickel does not have a formatter, which it should ideally have.
The current parser and ast are not suited for this purpose since they perform
desugaring during decoding and drop all information on whitespace and
comments. For example, the following program:
```nickel
{
  // This bar is very important
  foo.bar = "bar",
  foo.baz = "baz",
}
```

Parses to:
```nickel
{
  foo = { bar = "bar"} & { baz = "baz" },
}
```

This note explores the options we have within the rust ecosystem to construct a
full fidelity (or lossless) AST.

# Keeping the existing lalrpop grammar
The current lexing/parsing stack of Nickel is based on a lexer generated using
[logos][logos], a parser generated by
[lalrpop][lalrpop], and a native AST.

Our initial idea was to keep the existing lalrpop grammar in place, but
replacing the AST with a [rowan][rowan] based
alternative. Unfortunately, while it is possible to integrate logos, rowan, and
lalrpop, comments and whitespace would still be lost. This is an inherent
problem with lalrpop in which grammar rules match directly on the token input.

# The problem with comments/whitespace
Above, it was stated that the way lalrpop consumes the token input stream is
not well suited for a formatter (or other programming tools). This is a general
problem with parsers that attempt to construct a typed AST directly (there is
no place for comments in a typed AST. There are ways around this, but they
broadly fall into two categories:
1. Don't have a typed AST. For these solutions, an untyped AST is used instead,
   that is optionally converted to a typed AST when needed.
2. Lose some information by "intelligently" assigning every comment to a node
   in the typed AST. The loss in information here means, for instance, that we
   have to assign a comment surrounded by empty lines to a expression somewhere
   near it.

# Options
## Custom
Like rustc, nickel could employ a custom lexer and parser.

### Advantages
- Full control

### Disadvantages
- By far the most work
- Rapid development is harder when implementing a parser from scratch

## [Rowan][rowan] + [Ungrammar][ungrammar] (optional) + [Logos][logos]
Rowan and Ungrammar are two libraries created for the
[rust-analyzer][rust-analyzer] project.

Of course, rust-analyzer is greatly benefitted by a lossless ast (CSTs as
they call them). To this extend they created two libraries specifically for
this purpose. [rowan][rowan] and [ungrammar][ungrammar].

Rowan is a library that has been adopted for use in
[several](https://crates.io/crates/rowan/reverse_dependencies) language servers
and other programming tools.
Additionally, there exists at least
[one language (slin)](https://github.com/slint-ui/slint/) that (aside from a
language server and formatter) also uses rowan for their
[compiler](https://github.com/slint-ui/slint/tree/master/internal/compiler).
Hence we can safely say rowan is likely suitable for nickel.

Ungrammar is "a ... formalism for describing concrete syntax trees". Concretely,
ungrammar takes a
[file written in its grammar](https://github.com/rust-analyzer/ungrammar/blob/master/rust.ungram)
and produces
[a file](https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/syntax/src/ast/generated/nodes.rs)
that contains functions used to interact with the GreenNodes/lossess syntax
tree (typically produced by rowan). Ungrammar has seen limited/no use outside
of rust-analyzer.
The main advantage of ungrammar is that it allows the syntax of a language to
be changed easily without requiring manual changes to the syntax tree. This can
be a great benefit in the early stages of development when changes to the CST
are frequent. More on ungrammar can be read in a
[relevant blogpost](https://rust-analyzer.github.io/blog/2020/10/24/introducing-ungrammar.html).

Since we can no longer use lalrpop, the parser would have to be written by
hand. Parser combinators are not very suitable to this approach, as many
are based around a parser succeeding or failing, negating rowan's advantage of
being able to produce an AST even when there is an error.

There is of course nothing fundamentally impossible about using some parser
combinator library.

### Advantages
- Rowan has seen use for compilers, language servers, and formatters.
- Logos and Rowan can work nicely together, because the created parser links
  them together.

### Disadvantages
- We would have to manually write an additional layer for the SyntaxNodes
- We will need two SyntaxNodes implementations, one used for the formatter, one
  used to construct the current AST.

## Comment map/assigning comments
Another approach is used by [ucg](https://github.com/zaphar/ucg) and
[nixfmt](https://github.com/serokell/nixfmt) that both associate a comment with
nodes in the AST. Either by looking them up during pretty printing (thus saving
having them in the AST for other purposes), or having every node in the tree
have an optional associated comment.

This method is obviously not lossless in the sense that whitespace is still
removed, but it would suit our purpose. There are some challenges related to
how to format associated comments, especially comments that were not intended
to be associated with anything.

### Advantages
- This is a safe option, ucg is a language much like nickel
- Allows us to use any parser combinator library

### Disadvantages
- Not lossless

## Tree-sitter?
In issue [#656](https://github.com/tweag/nickel/issues/656), Yann remarked that
there are multiple grammar definitions for the nickel language. It would be nice to share a
grammar for editors and nickel itself. Tree-sitter's concept is not too far
removed from rowan (an untyped tree that is easy to update) with similar
purposes (to ease the creation of development tools). Aside from
[toy-examples](https://github.com/vanhtuan0409/toon-lang) there are, however,
no existing projects that utilize tree-sitter as a parser for a
rts/compiler/etc. I don't see a fundamental problem that would stop us from
using tree-sitter as a parser.

## Don't use a uniform parser
While the concept of using the same parser for the interpreter and
formatter/other tools is nice, we ought to also consider the fact that these
tools have distinctly varying purposes. In short, a lossless parser just
doesn't serve any purpose to the nickel binary. Based on current experience
with the lalrpop parser, it might actually introduce more overhead if we try to
use the same parser for both.

# Proposed approach
I can't recommend any solution without input from those who have worked with 
the current lalrpop grammar. Depending on how hard it was to implement that, we
should determine if integrating a lossless ast with the nickel binary is
desirable. If so, I think the [rowan][rowan] + [logos][logos] + a custom parser
is the most sustainable approach.

[rowan]: https://lib.rs/crates/rowan
[logos]: https://lib.rs/crates/logos
[lalrpop]: https://lib.rs/crates/lalrpop
[ungrammar]: https://lib.rs/crates/ungrammar
[rust-analyzer]: https://rust-analyzer.github.io/
