# Notes on a full fidelity parser
Nickel does not have a formatter, which it should ideally have.
The current parser and ast are not suited for this purpose since they perform
desugaring during decoding and drop all information on whitespace and
comments. For example, the following program:
```nickel
{
  // This bar is very important
  foo.bar = "bar",
  foo.baz = "baz",
}
```

Parses to:
```nickel
{
  foo = { bar = "bar"} & { baz = "baz" },
}
```

This note explores the options we have within the rust ecosystem to construct a
full fidelity (or lossless) AST.

# Keeping the existing lalrpop grammar
The current lexing/parsing stack of Nickel is based on a lexer generated using
[logos][logos], a parser generated by
[lalrpop][lalrpop], and a native AST.

Our initial idea was to keep the existing lalrpop grammar in place, but
replacing the AST with a [rowan][rowan] based
alternative. Unfortunately, while it is possible to integrate logos, rowan, and
lalrpop, comments and whitespace would still be lost. This is an inherent
problem with lalrpop in which grammar rules match directly on the token input.
Hence, dealing with whitespace for an operator 4 variants (whitespace optional
on both sides).

This thus implies that lalrpop has to be replaced.

# Options
## Custom
Like rustc, nickel could employ a custom lexer and parser.

### Advantages
- Full control

### Disadvantages
- By far the most work
- Rapid development is harder when implementing a parser from scratch

## [Rowan][rowan] + [Ungrammar][ungrammar] (optional) + [Logos][logos]
Rowan and Ungrammar are two libraries created for the
[rust-analyzer][rust-analyzer] project.

Of course, rust-analyzer is greatly benefitted by a lossless ast (CSTs as
they call them). To this extend they created two libraries specifically for
this purpose. [rowan][rowan] and [ungrammar][ungrammar].

Rowan is a widespread library that has already seen use in existing languages.
For instance for the
[slint](https://github.com/slint-ui/slint/) language that make use of rowan for
their language server and
[compiler](https://github.com/slint-ui/slint/tree/master/internal/compiler).
Hence we can safely say rowan is likely suitable for nickel.

Ungrammar is a grammar that works to construct the SyntaxNodes as described in
[syntax overview](https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/syntax.md)
of rust-analyzer. Ungrammar has not seen use outside of rust-analyzer. I
personally do not see a need for Nickel to base its SyntaxNodes on ungrammar.

Since we can no longer use lalrpop, the parser would have to be written by
hand. Parser combinators are not very suitable to this approach, as many
are based around a parser succeeding or failing, negating rowan's advantage of
being able to produce an AST even when there is an error.

There is of course nothing fundamentally impossible about using some parser
combinator library.

### Advantages
- Rowan has seen use for compilers, language servers, and formatters.
- Logos and Rowan can work nicely together, because the created parser links
  them together.

### Disadvantages
- We would have to manually write an additional layer for the SyntaxNodes
- We will need two SyntaxNodes implementations, one used for the formatter, one
  used to construct the current AST.

## Comment map/assigning comments
Another approach is used by [ucg](https://github.com/zaphar/ucg) and
[nixfmt](https://github.com/serokell/nixfmt) that both associate a comment with
nodes in the AST. Either by looking them up during pretty printing (thus saving
having them in the AST for other purposes), or having every node in the tree
have an optional associated comment.

This method is obviously not lossless in the sense that whitespace is still
removed, but it would suit our purpose. There are some challenges related to
how to format associated comments, especially comments that were not intended
to be associated with anything.

### Advantages
- This is a safe option, ucg is a language much like nickel
- Allows us to use any parser combinator library

### Disadvantages
- Not lossless

## Tree-sitter?
In issue [#656](https://github.com/tweag/nickel/issues/656), Yann remarked that
there are multiple grammar definitions for the nickel language. It would be nice to share a
grammar for editors and nickel itself. Tree-sitter's concept is not too far
removed from rowan (an untyped tree that is easy to update) with similar
purposes (to ease the creation of development tools). Aside from
[toy-examples](https://github.com/vanhtuan0409/toon-lang) there are, however,
no existing projects that utilize tree-sitter as a parser for a
rts/compiler/etc. I don't see a fundamental problem that would stop us from
using tree-sitter as a parser.

## Don't use a uniform parser
While the concept of using the same parser for the interpreter and
formatter/other tools is nice, we ought to also consider the fact that these
tools have distinctly varying purposes. In short, a lossless parser just
doesn't serve any purpose to the nickel binary. Based on current experience
with the lalrpop parser, it might actually introduce more overhead if we try to
use the same parser for both.

# Proposed approach
I can't recommend any solution without input from those who have worked with 
the current lalrpop grammar. Depending on how hard it was to implement that, we
should determine if integrating a lossless ast with the nickel binary is
desirable. If so, I think the [rowan][rowan] + [logos][logos] + a custom parser
is the most sustainable approach.

[rowan]: https://lib.rs/crates/rowan
[logos]: https://lib.rs/crates/logos
[lalrpop]: https://lib.rs/crates/lalrpop
[ungrammar]: https://lib.rs/crates/ungrammar
[rust-analyzer]: https://rust-analyzer.github.io/
